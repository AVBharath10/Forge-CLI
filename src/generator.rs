
#[derive(Debug, Clone, PartialEq)]
pub enum FrontendFramework {
    None,
    NextJs,
    React,
}

#[derive(Debug, Clone, PartialEq)]
pub enum BackendFramework {
    None,
    Express,
    FastAPI,
}

#[derive(Debug, Clone)]
pub enum Database {
    Postgres,
    MySQL,
    MongoDB,
    SQLite,
}

#[derive(Debug, Clone)]
pub enum Auth {
    None,
    Jwt,
}

pub fn generate_env(frontend: &FrontendFramework, backend: &BackendFramework, auth: &Auth, db: &Database) -> String {
    let mut env = String::new();

    match db {
        Database::Postgres => env.push_str("DATABASE_URL=\"postgresql://appuser:applocal@localhost:5432/appdb\"\n"),
        Database::MySQL => env.push_str("DATABASE_URL=\"mysql://appuser:applocal@localhost:3306/appdb\"\n"),
        Database::MongoDB => env.push_str("DATABASE_URL=\"mongodb://localhost:27017/appdb\"\n"),
        Database::SQLite => env.push_str("DATABASE_URL=\"file:./dev.db\"\n"),
    }

    match frontend {
        FrontendFramework::NextJs => {
            env.push_str("NEXT_PUBLIC_API_URL=\"http://localhost:3001\"\n");
            env.push_str("NEXT_PUBLIC_APP_NAME=\"forge-app\"\n");
        }
        FrontendFramework::React => {
            env.push_str("VITE_API_URL=\"http://localhost:3000\"\n");
            env.push_str("VITE_APP_NAME=\"forge-app\"\n");
        }
        FrontendFramework::None => {}
    }

    match backend {
        BackendFramework::Express => {
            env.push_str("PORT=3001\n");
            env.push_str("NODE_ENV=development\n");
        }
        BackendFramework::FastAPI => {
            env.push_str("PORT=8000\n");
            env.push_str("ENV=development\n");
        }
        BackendFramework::None => {}
    }

    match auth {
        Auth::None => {}
        Auth::Jwt => {
            env.push_str("JWT_SECRET=\"change-me-super-secret-key\"\n");
            if let FrontendFramework::NextJs = frontend {
                env.push_str("NEXTAUTH_URL=\"http://localhost:3000\"\n");
            }
        }
    }

    env
}

pub fn generate_express_files(name: &str, db: &Database, auth: &Auth) -> Vec<(&'static str, String)> {
    let (db_dep, db_code) = match db {
        Database::Postgres => (
            "\"pg\": \"^8.11.3\"",
            r#"const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
module.exports = {
  query: (text, params) => pool.query(text, params),
};"#
        ),
        Database::MySQL => (
            "\"mysql2\": \"^3.6.5\"",
            r#"const mysql = require('mysql2/promise');
const pool = mysql.createPool(process.env.DATABASE_URL);
module.exports = pool;"#
        ),
        Database::MongoDB => (
            "\"mongoose\": \"^8.0.3\"",
            r#"const mongoose = require('mongoose');
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.DATABASE_URL);
    console.log('MongoDB Connected');
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
};
module.exports = connectDB;"#
        ),
        Database::SQLite => (
            "\"sqlite3\": \"^5.1.6\"",
            r#"const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database(process.env.DATABASE_URL.replace('file:', ''), (err) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log('Connected to the SQLite database.');
  }
});
module.exports = db;"#
        ),
    };

    // Add Auth dependencies
    let auth_deps = match auth {
        Auth::Jwt => ",\n    \"jsonwebtoken\": \"^9.0.2\",\n    \"bcryptjs\": \"^2.4.3\"",
        Auth::None => "",
    };

    let package_json = format!(
        r#"{{
  "name": "{}",
  "version": "1.0.0",
  "description": "Generated by Forge",
  "main": "src/index.js",
  "scripts": {{
    "start": "node src/index.js",
    "dev": "nodemon src/index.js"
  }},
  "dependencies": {{
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "{}{}"
  }},
  "devDependencies": {{
    "nodemon": "^3.0.1"
  }}
}}"#,
        name, db_dep, auth_deps
    );

    let db_import = match db {
        Database::MongoDB => "const connectDB = require('./db');\nconnectDB();",
        _ => "const db = require('./db');",
    };

    let auth_imports = match auth {
        Auth::Jwt => "const authRoutes = require('./routes/auth');",
        Auth::None => "",
    };

    let auth_routes_mount = match auth {
        Auth::Jwt => "app.use('/api/auth', authRoutes);",
        Auth::None => "",
    };

    let index_js = format!(
        r#"require('dotenv').config();
const express = require('express');
const cors = require('cors');
{}
{}

const app = express();
const port = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

{}

app.get('/', (req, res) => {{
  res.json({{ message: 'Hello from Forge Express with DB!' }});
}});

app.listen(port, () => {{
  console.log(`Server running on port ${{port}}`);
}});
"#,
        db_import, auth_imports, auth_routes_mount
    );

    let mut files = vec![
        ("package.json", package_json),
        ("src/index.js", index_js),
        ("src/db.js", db_code.to_string()),
    ];

    if let Auth::Jwt = auth {
        let auth_route_code = r#"const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

// Mock User DB for starter
const users = [];

router.post('/register', async (req, res) => {
  const { username, password } = req.body;
  const hashedPassword = await bcrypt.hash(password, 10);
  users.push({ username, password: hashedPassword });
  res.status(201).json({ message: 'User registered' });
});

router.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username);
  if (!user) return res.status(400).json({ message: 'User not found' });

  const isMatch = await bcrypt.compare(password, user.password);
  if (!isMatch) return res.status(400).json({ message: 'Invalid credentials' });

  const token = jwt.sign({ username: user.username }, process.env.JWT_SECRET, { expiresIn: '1h' });
  res.json({ token });
});

module.exports = router;"#;
        
        files.push(("src/routes/auth.js", auth_route_code.to_string()));
    }

    files
}

pub fn generate_fastapi_files(_name: &str, db: &Database, auth: &Auth) -> Vec<(&'static str, String)> {
    let (db_req, db_file, db_import) = match db {
        Database::MongoDB => (
            "motor>=3.3.1",
            r#"import os
from motor.motor_asyncio import AsyncIOMotorClient

client = AsyncIOMotorClient(os.getenv("DATABASE_URL"))
db = client.appdb
"#,
            "from database import db"
        ),
        _ => (
            "sqlalchemy>=2.0.23\npsycopg2-binary>=2.9.9" /* Assuming PG default for simplicity in SQL block */, 
            r#"from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
"#,
             "from database import engine, Base\n# Base.metadata.create_all(bind=engine)"
        )
    };
    
    // Adjust requirements for specific SQLs
    let final_req = match db {
        Database::Postgres => format!("{}\nasyncpg>=0.29.0", db_req), // asyncpg if needed, or psycopg2
        Database::MySQL => format!("{}\nmysqlclient>=2.2.0", db_req.replace("psycopg2-binary>=2.9.9", "")),
        Database::SQLite => db_req.replace("psycopg2-binary>=2.9.9", ""), // built-in
        _ => db_req.to_string(),
    };

    let auth_req = match auth {
        Auth::Jwt => "\npython-jose[cryptography]>=3.3.0\npasslib[bcrypt]>=1.7.4\npython-multipart>=0.0.6",
        Auth::None => "",
    };

    let requirements = format!("fastapi>=0.100.0\nuvicorn>=0.23.0\npython-dotenv>=1.0.0\n{}{}", final_req, auth_req);

    let auth_imports = match auth {
        Auth::Jwt => "from auth import router as auth_router",
        Auth::None => "",
    };

    let auth_include = match auth {
        Auth::Jwt => "app.include_router(auth_router, prefix=\"/auth\", tags=[\"auth\"])",
        Auth::None => "",
    };

    let main_py = format!(
        r#"from fastapi import FastAPI
from dotenv import load_dotenv
import os
{}
{}

load_dotenv()

app = FastAPI()

{}

@app.get("/")
def read_root():
    return {{"message": "Hello from Forge FastAPI!"}}

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
"#,
        db_import, auth_imports, auth_include
    );

    let mut files = vec![
        ("requirements.txt", requirements),
        ("main.py", main_py),
        ("database.py", db_file.to_string()),
    ];

    if let Auth::Jwt = auth {
        let auth_code = r#"from fastapi import APIRouter, HTTPException, Depends, status
from pydantic import BaseModel
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
import os

router = APIRouter()

SECRET_KEY = os.getenv("JWT_SECRET", "secret")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Mock DB
fake_users_db = {}

class User(BaseModel):
    username: str
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

@router.post("/register", status_code=201)
def register(user: User):
    if user.username in fake_users_db:
        raise HTTPException(status_code=400, detail="User already registered")
    fake_users_db[user.username] = {
        "username": user.username,
        "hashed_password": get_password_hash(user.password)
    }
    return {"msg": "User created"}

@router.post("/token", response_model=Token)
def login_for_access_token(user: User):
    user_in_db = fake_users_db.get(user.username)
    if not user_in_db or not verify_password(user.password, user_in_db['hashed_password']):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}
"#;
        files.push(("auth.py", auth_code.to_string()));
    }

    files
}

pub fn generate_docker_compose(db: &Database) -> Option<String> {
    match db {
        Database::Postgres => Some(r#"version: "3.8"
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: applocal
    ports:
      - "5432:5432"
"#.to_string()),
        Database::MySQL => Some(r#"version: "3.8"
services:
  db:
    image: mysql:8
    environment:
      MYSQL_DATABASE: appdb
      MYSQL_USER: appuser
      MYSQL_PASSWORD: applocal
      MYSQL_ROOT_PASSWORD: rootpassword
    ports:
      - "3306:3306"
"#.to_string()),
        Database::MongoDB => Some(r#"version: "3.8"
services:
  db:
    image: mongo:latest
    environment:
      MONGO_INITDB_DATABASE: appdb
    ports:
      - "27017:27017"
"#.to_string()),
        Database::SQLite => None,
    }
}

pub fn generate_ci_cd(name: &str, is_fullstack: bool) -> String {
    let build_step = if is_fullstack {
        r#"
      - name: Install Frontend Dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Build Frontend
        working-directory: ./frontend
        run: npm run build

      - name: Install Backend Dependencies
        working-directory: ./backend
        run: |
          if [ -f "package.json" ]; then
            npm ci
          elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          fi
"#
    } else {
        r#"
      - name: Install Dependencies
        run: |
          if [ -f "package.json" ]; then
            npm ci
          elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          fi

      - name: Build
        run: |
          if [ -f "package.json" ] && grep -q "build" package.json; then
            npm run build
          fi
"#
    };

    format!(
        r#"name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
{}
"#,
        build_step
    )
}
