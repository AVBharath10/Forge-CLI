
#[derive(Debug, Clone, PartialEq)]
pub enum FrontendFramework {
    None,
    NextJs,
    React,
}

#[derive(Debug, Clone, PartialEq)]
pub enum BackendFramework {
    None,
    Express,
    FastAPI,
}

#[derive(Debug, Clone)]
pub enum Database {
    Postgres,
    MySQL,
    MongoDB,
    SQLite,
}

#[derive(Debug, Clone)]
pub enum Auth {
    None,
    Jwt,
}

pub fn generate_env(frontend: &FrontendFramework, backend: &BackendFramework, auth: &Auth, db: &Database) -> String {
    let mut env = String::new();

    match db {
        Database::Postgres => env.push_str("DATABASE_URL=\"postgresql://appuser:applocal@localhost:5432/appdb\"\n"),
        Database::MySQL => env.push_str("DATABASE_URL=\"mysql://appuser:applocal@localhost:3306/appdb\"\n"),
        Database::MongoDB => env.push_str("DATABASE_URL=\"mongodb://localhost:27017/appdb\"\n"),
        Database::SQLite => env.push_str("DATABASE_URL=\"file:./dev.db\"\n"),
    }

    match frontend {
        FrontendFramework::NextJs => {
            env.push_str("NEXT_PUBLIC_API_URL=\"http://localhost:3001\"\n");
            env.push_str("NEXT_PUBLIC_APP_NAME=\"forge-app\"\n");
        }
        FrontendFramework::React => {
            env.push_str("VITE_API_URL=\"http://localhost:3000\"\n");
            env.push_str("VITE_APP_NAME=\"forge-app\"\n");
        }
        FrontendFramework::None => {}
    }

    match backend {
        BackendFramework::Express => {
            env.push_str("PORT=3001\n");
            env.push_str("NODE_ENV=development\n");
        }
        BackendFramework::FastAPI => {
            env.push_str("PORT=8000\n");
            env.push_str("ENV=development\n");
        }
        BackendFramework::None => {}
    }

    match auth {
        Auth::None => {}
        Auth::Jwt => {
            env.push_str("JWT_SECRET=\"change-me-super-secret-key\"\n");
            if let FrontendFramework::NextJs = frontend {
                env.push_str("NEXTAUTH_URL=\"http://localhost:3000\"\n");
            }
        }
    }

    env
}

pub fn generate_express_files(name: &str, db: &Database) -> Vec<(&'static str, String)> {
    let (db_dep, db_code) = match db {
        Database::Postgres => (
            "\"pg\": \"^8.11.3\"",
            r#"const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});
module.exports = {
  query: (text, params) => pool.query(text, params),
};"#
        ),
        Database::MySQL => (
            "\"mysql2\": \"^3.6.5\"",
            r#"const mysql = require('mysql2/promise');
const pool = mysql.createPool(process.env.DATABASE_URL);
module.exports = pool;"#
        ),
        Database::MongoDB => (
            "\"mongoose\": \"^8.0.3\"",
            r#"const mongoose = require('mongoose');
const connectDB = async () => {
  try {
    await mongoose.connect(process.env.DATABASE_URL);
    console.log('MongoDB Connected');
  } catch (err) {
    console.error(err.message);
    process.exit(1);
  }
};
module.exports = connectDB;"#
        ),
        Database::SQLite => (
            "\"sqlite3\": \"^5.1.6\"",
            r#"const sqlite3 = require('sqlite3').verbose();
const db = new sqlite3.Database(process.env.DATABASE_URL.replace('file:', ''), (err) => {
  if (err) {
    console.error(err.message);
  } else {
    console.log('Connected to the SQLite database.');
  }
});
module.exports = db;"#
        ),
    };

    let package_json = format!(
        r#"{{
  "name": "{}",
  "version": "1.0.0",
  "description": "Generated by Forge",
  "main": "src/index.js",
  "scripts": {{
    "start": "node src/index.js",
    "dev": "nodemon src/index.js"
  }},
  "dependencies": {{
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    {}
  }},
  "devDependencies": {{
    "nodemon": "^3.0.1"
  }}
}}"#,
        name, db_dep
    );

    let db_import = match db {
        Database::MongoDB => "const connectDB = require('./db');\nconnectDB();",
        _ => "const db = require('./db');",
    };

    let index_js = format!(
        r#"require('dotenv').config();
const express = require('express');
const cors = require('cors');
{}

const app = express();
const port = process.env.PORT || 3001;

app.use(cors());
app.use(express.json());

app.get('/', (req, res) => {{
  res.json({{ message: 'Hello from Forge Express with DB!' }});
}});

app.listen(port, () => {{
  console.log(`Server running on port ${{port}}`);
}});
"#,
        db_import
    );

    vec![
        ("package.json", package_json),
        ("src/index.js", index_js),
        ("src/db.js", db_code.to_string()),
    ]
}

pub fn generate_fastapi_files(_name: &str, db: &Database) -> Vec<(&'static str, String)> {
    let (db_req, db_file, db_import) = match db {
        Database::MongoDB => (
            "motor>=3.3.1",
            r#"import os
from motor.motor_asyncio import AsyncIOMotorClient

client = AsyncIOMotorClient(os.getenv("DATABASE_URL"))
db = client.appdb
"#,
            "from database import db"
        ),
        _ => (
            "sqlalchemy>=2.0.23\npsycopg2-binary>=2.9.9" /* Assuming PG default for simplicity in SQL block */, 
            r#"from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

SQLALCHEMY_DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(SQLALCHEMY_DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()
"#,
             "from database import engine, Base\n# Base.metadata.create_all(bind=engine)"
        )
    };
    
    // Adjust requirements for specific SQLs
    let final_req = match db {
        Database::Postgres => format!("{}\nasyncpg>=0.29.0", db_req), // asyncpg if needed, or psycopg2
        Database::MySQL => format!("{}\nmysqlclient>=2.2.0", db_req.replace("psycopg2-binary>=2.9.9", "")),
        Database::SQLite => db_req.replace("psycopg2-binary>=2.9.9", ""), // built-in
        _ => db_req.to_string(),
    };

    let requirements = format!("fastapi>=0.100.0\nuvicorn>=0.23.0\npython-dotenv>=1.0.0\n{}", final_req);

    let main_py = format!(
        r#"from fastapi import FastAPI
from dotenv import load_dotenv
import os
{}

load_dotenv()

app = FastAPI()

@app.get("/")
def read_root():
    return {{"message": "Hello from Forge FastAPI!"}}

if __name__ == "__main__":
    import uvicorn
    port = int(os.getenv("PORT", 8000))
    uvicorn.run(app, host="0.0.0.0", port=port)
"#,
        db_import
    );

    vec![
        ("requirements.txt", requirements),
        ("main.py", main_py),
        ("database.py", db_file.to_string()),
    ]
}

pub fn generate_docker_compose(db: &Database) -> Option<String> {
    match db {
        Database::Postgres => Some(r#"version: "3.8"
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: appdb
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: applocal
    ports:
      - "5432:5432"
"#.to_string()),
        Database::MySQL => Some(r#"version: "3.8"
services:
  db:
    image: mysql:8
    environment:
      MYSQL_DATABASE: appdb
      MYSQL_USER: appuser
      MYSQL_PASSWORD: applocal
      MYSQL_ROOT_PASSWORD: rootpassword
    ports:
      - "3306:3306"
"#.to_string()),
        Database::MongoDB => Some(r#"version: "3.8"
services:
  db:
    image: mongo:latest
    environment:
      MONGO_INITDB_DATABASE: appdb
    ports:
      - "27017:27017"
"#.to_string()),
        Database::SQLite => None,
    }
}
